.TH "prex" "1" "12.11.2016"

.SH НАЗВАНИЕ
.RS 2
prex 
\- система отслеживания и управления пробными точками в процессе или ядре
.RE

.SH СИНТАКСИС
.RS 2
.PP
prex [-o файл_трассировки] [-l библиотеки] [-s размер_в_кб] cmd [cmd-аргументы]...
.PP
prex [-o файл_трассировки] [-l библиотеки] [-s размер_в_кб] -p pid
.PP
prex -k [-s размер_в_кб]
.RE

.SH ОПИСАНИЕ 
.RS 2
prex загружает библиотеку libtnfprobe, а затем находит все пробы в целевом исполняемом файле или ядре и предоставляет интерфейс пользователю для управления ими. Это позволяет probe измениться для трассировки, отладки или того и друго вместе. Трассировка создает трассировочный файл TNF (Trace Normal Form), который может быть конвертирован в ASCII с помощью tnfdump(1) и использован для анализа производительности. Отладка генерирует строку стандартной ошибки при падении во время выполнения.

prex работает только на динамических исполняемых файлах.
.RE

Вызов PREX
.RS 2
Существует три способа запуска prex:
.TP 
1. 
Использование prex для старта целевых приложений cmd, которые построенны  без зависимости от libtnfprobe. prex устанавливает переменную окружения LD_PRELOAD для загрузки libtnfprobe в целевом процессе. Затем prex использует переменную окружения PATH для поиска целевого приложения.
.TP
2.
Прикрепление prex к запущенному приложению. Запущенное приложение должно уже иметь связь с libtnfprobe. В качестве альтернативы, пользователь может вручную установить LD_PRELOAD для включения libtnfprobe.so.1 до вызова цели.
.TP
3.
Использование prex в режиме ядра с ключом -k. В режиме ядра будут доступны дополнительные команды, но некоторые команды из других режимов станут недоступны.
.RE

Управление файлом поиска пути
.RS 2
Есть два различных способа общения с prex:
.IP \(bu 5
Характеристика управляющего файла. Во время запуска prex ищет файлы с именем .prexrc в каталогах указаных ниже. prex не останавливается на первом найденом. Порядок поиска:
.nf
	$HOME/ 
	./
.fi
.IP \(bu 5
Ввод команд в строке prex. 
.RE

.RS 2
Язык команд одинаков для обоих методов и задается в USAGE. Команды, которые что-то возвращают, не будут иметь смысла в управляющем файле. Вывод будет идти на стандартный поток вывода.

При использовании prex в целевом процессе, цель будет в запущенном или приостановленом состоянии. Это выясняется наличием или отсутствием подсказки prex>. Если подсказки нет, то целевой процесс запущен. Нажатие Control-C остановит целевой процесс и вернет пользователю подсказку. Однако, нет гарантии, что возврат подсказки произойдет сразу.  
.RE

.SH ОПЦИИ
Команда поддерживает следующие ключи:
.RS 2
.IP "-k" 20
Режим ядра: В режиме ядра будут доступны дополнительные команды, но некоторые команды из других режимов станут недоступны.
.IP "-l libraries" 20
Упомянутые библиотеки связаны в целевом процессе, использующим LD_PRELOAD. Этот ключ не может быть использован для присоединения к запущенному процессу. Аргумент ключа -l должен быть строкой, разделенной пробелами и заключенной в двойные ковычки. 
.IP "-o файл_трассир" 20
В файл будет записан вывод трассировки. Файл_трассировки считается относительно текущей рабочей директории.

Если prex присоединяется к уже запущенноу процессу, то новый файл_трассировки не будет использоваться. Если имя файла не указано, то по уолчанию используется /$TMPDIR/trace-pid, где pid - ИД целевой программы. Если TMPDIR не задан, то используется /tmp.
.IP "-s размер_в_кб" 20
Максимальный размер выходного файла трассировки в кбайтах. По умолчанию, размер 4096 кбайт для нормального использования и 384 кбайт в режиме ядра. Минимальный размер составляет 128 кбайт.
.RE

.SH СМОТРИТЕ ТАКЖЕ
.RS 2
ed(1), kill(1),  ksh(1),  ld(1)
.RE
